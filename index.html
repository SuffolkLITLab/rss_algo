<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>RSS Algo</title>
	<meta property="og:site_name" content="RSS Algo"/>
	<meta property="og:type" content="website"/>
	<meta property="og:title" content="RSS Algo"/>
	<meta property="og:description" content="An algorithmic RSS reader where your data stays on your device."/>
	<meta property="og:image" content="images/placeholder.png"/>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        /* Your custom styles can go here */
        .read-article .card {
            opacity: 0.5; /* Slightly transparent for read items */
        }
        .read-article .skip {
            display:none;
        }
        .read-article .card-title,
        .read-article .card-text,
        .read-article .feed-tag {
            color: black; /* Standard blac
            k text for read items */
        }
        .article-container {
            margin-bottom: 15px;
        }
        .card-title {
            float:left;
            width:100%;
        }

        .feed-tag {
            font-size: 12px;
            color: #fff0f0;
        }
        .upvote {
            background: rgb(212, 255, 212)
        }
        .downvote {
            background: rgb(255, 216, 216);
        }
        .thumbs-up {
            background: green
        }
        .thumbs-down {
            background: red;
        }
        .priority-rating {
            font-size: 18px;
            margin-right: 5px;
            float:left;
            width:100%;
        }
        #read-count,
        #unread-count {
            font-weight: bold;
            margin-right: 10px;
        }
        .thumbnail-image {
            object-position: center 33%;
            max-height: 200px;
            object-fit: cover;
        }

        .row-equal-height {
            display: flex;
            flex-wrap: wrap;
        }

        .card {
            display: flex;
            flex-direction: column;
            height: 100%; /* Make the card grow to the full height of its container */
        }

        .card-body {
            flex: 1; /* Allow the card body to grow and fill the remaining space */
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* Space between the title and other elements */
        }

        .card-title {
            font-size: 1.25rem; /* Larger font size for the title */
            margin-bottom: 0.5rem; /* Add some spacing below the title */
        }

        .card-text {
            flex-grow: 1; /* Allow the description to expand to fill space */
            margin-bottom: 1rem; /* Add spacing at the bottom of the description */
        }

        .feed-tag {
            color: black;
            margin-top: auto; /* Push the feed tag to the bottom of the card */
        }

        .btn-group {
            margin-top: auto; /* Push the button group to the bottom of the card */
        }
        .my-1 {
            font-size: 35px;
            line-height: 30px;
            margin-bottom: 20px;
        }
        .btn-block{
            width:100%;
            margin-bottom: 12px;
        }
        .footer {
            border-top: 1px solid #555;
            margin: 20px 0 40px 0;
            padding: 10px 5px;
        }
        
        /* Dark mode styles */
        .dark-mode {
            background-color: #333;
            color: #fff;
        }
        .dark-mode a {
            color: #88e3ff;
        }
        .dark-mode .btn-primary {
            color: #ffffff;
        }
        .dark-mode .card {
            background-color: #333;
            border-color: #4e4e4e;
            color: #fff;
        }               
        .dark-mode .text-muted {
            color: #6a6a6a !important;
        }     
        .dark-mode .card-footer {
            background-color: #4e4e4e;
        }  
        .dark-mode .feed-tag {
            color: #fff;
        }  
        .dark-mode .read-article .card {
            opacity: 0.6;
        }

        .dark-mode .read-article .card-title,
        .dark-mode .read-article .card-text,
        .dark-mode .read-article .feed-tag {
            color: #ccc;
        }
    </style>
    </head>
<body>
    <div class="container">
        <div style="float:left;width:100%;margin-top: 20px;">
            <div style="float:right;">
                <button id="toggle-mode" class="btn btn-secondary" aria-label="Toggle Dark Mode">üåó</button>
                <button id="manage-feeds" class="btn btn-secondary">My Feeds</button>
                <button id="add-feed" class="btn btn-primary">+</button>
            </div>
            <div style="float:left;"><h1 class="my-1">RSS Algo</h1></div>
            <div style="float:left;width:100%;padding-top: 8px;">No tracking? No problem. Your data and your algo, living on your device. <a href="https://github.com/colarusso/rss_algo#rss_algo" target="_blank">Learn More</a> </div>
            <span id="loading" style="float:left;background:yellow;display:none;margin-right: 10px;color:black;"><i>Loading...</i></span>
        <div class="my-3" style="float:left;width:100%;">
            <span style="float:right"><a href="#my_data">My Data</a></span>
            <span id="unread-count" class="text-danger">Unread: ?</span>
            <span id="read-count" class="text-success">Seen: ?</span>
        </div>
        </div>
        <div id="news-feed" class="row">
            <!-- News articles will be dynamically added here -->
        </div>

        <div class="container mt-4">
            <a name="my_data"></a>
            <h2>My Data</h2>
            <p>You can manage your feeds by clicking "My Feeds" at the <a href="javascript:void('')" onClick="history.replaceState('', document.title, window.location.pathname);window.scrollTo(0, 0);">top</a> of this page. See additional controls below. To determine what articles you like, we make use of <a href="https://en.wikipedia.org/wiki/Tf%E2%80%93idf" target="_blank">TF-IDF</a>, comparing all the text from the cards you vote up or down with everything you've "seen." FWIW, recomendations won't kick in until you've seen north of 100 cards. I hope to write a more complete explanation sometime. When I do, I'll put a link here. Until then, you can always look at <a href="https://github.com/colarusso/rss_algo" target="_blank">the code</a>.</p>
            <div class="row">
                <div class="col-xl-4 col-lg-5 col-md-6 col-sm-12 col-md-4">
                    <h4>Postive</h4>
                    <p>Here are your <b><i>most-postive</i></b> words: <span id="upwords">not enough data</span></p>
                    <button id="clear-upvotes" class="btn btn-danger btn-block">Clear Upvotes</button>
                </div>
                <div class="col-xl-4 col-lg-5 col-md-6 col-sm-12 col-md-4">
                    <h4>Negative</h4>
                    <p>Here are your <b><i>most-negative</i></b> words: <span id="downwords">not enough data</span></p>
                    <button id="clear-downvotes" class="btn btn-danger btn-block">Clear Downvotes</button>
                </div>
                <div class="col-xl-4 col-lg-5 col-md-6 col-sm-12 col-md-4">
                    <h4>History</h4>
                    Display content from the last <b><i><span id="lookback-value">7</span> days</i></b>. <i>Refresh page to see results</i>.
                    <p>
                        <input type="range" id="lookback-slider" min="1" max="30" value="14" style="width:100%;">
                    </p>
                    <p>You can limit how much you see in your timeline by adjusting the slider above. If you clear you reading history, it will effect your recomendations since they're based on interactions with old articles. That is, we'll only be able to use data from old artiles if they get downloaded again.</p>
                    <button id="clear-read-history" class="btn btn-danger btn-block">Clear Reading History</button>
                    <button id="factory-reset" class="btn btn-danger btn-block factory-reset" onClick="reset_all();"><b>RESET ALL</b></button>
                </div>
            </div>
            <div class="footer">
                <span style="float:right">
                    <a href="https://github.com/colarusso/rss_algo" target="_blank">GitHub Repo</a>
                </span>
                Made by <a href="https://mastodon.social/@Colarusso" target="_blank">David Colarusso</a>
            </div>
        </div>            

    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>

        function reset_all() {
            let text = "This will erase all of your data and rest the list of feeds to default values. Choose OK to continue.";
            if (confirm(text) == true) {
                history.replaceState('', document.title, window.location.pathname);
                localStorage.clear();
                sessionStorage.clear();
                window.location.reload(true);
            }
        }

        document.addEventListener("DOMContentLoaded", function() {
            let rssFeeds = JSON.parse(localStorage.getItem("feeds")) || [
                "https://rss.nytimes.com/services/xml/rss/nyt/HomePage.xml",
                "https://rss.nytimes.com/services/xml/rss/nyt/Technology.xml",
                "https://rss.nytimes.com/services/xml/rss/nyt/Science.xml",
                "https://rss.nytimes.com/services/xml/rss/nyt/Space.xml",
                "https://rss.nytimes.com/services/xml/rss/nyt/Books/Review.xml",
                "https://rss.nytimes.com/services/xml/rss/nyt/MostEmailed.xml",
                "https://rss.nytimes.com/services/xml/rss/nyt/MostShared.xml",
                "https://rss.nytimes.com/services/xml/rss/nyt/MostViewed.xml"
                // Add more default RSS feed URLs here
            ];

            function arr2obj(arr) {
                return arr.reduce(
                    (acc, curr) => {
            
                        // Extract the key and the value
                        let key = curr[0];
                        let value = curr[1];
            
                        // Assign key and value
                        // to the accumulator
                        acc[key] = value;
            
                        // Return the accumulator
                        return acc;
                    },
            
                    // Initialize with an empty object
                    {}
                );
            }

            const newsFeedContainer = document.getElementById("news-feed");
            const upvotes =  JSON.parse(localStorage.getItem("upvotes")) || {};
            const downvotes = JSON.parse(localStorage.getItem("downvotes")) || {};
            const upTFIDF =  JSON.parse(localStorage.getItem("upTFIDF")) || {};
            const downTFIDF =  JSON.parse(localStorage.getItem("downTFIDF")) || {};
            const readArticles = filterOldEntries(JSON.parse(localStorage.getItem("read")) || {});

            var articles =  JSON.parse(localStorage.getItem("articles")) || [];

            function updateFeedList(loadFeeds = false) {
                localStorage.setItem("feeds", JSON.stringify(rssFeeds));
                let upTFIDF =  JSON.parse(localStorage.getItem("upTFIDF")) || {};
                let downTFIDF =  JSON.parse(localStorage.getItem("downTFIDF")) || {};
                loadNews(loadFeeds);
            }

            var n_feeds = 0;
            async function fetchFeed(feedUrl) {
                document.getElementById('loading').style.display = "block";
                const response = await fetch(feedUrl);
                if (!response.ok) {
                    throw new Error(`Request failed with status ${response.status}`);
                }
                const data = await response.text();
                n_feeds += 1;
                if (n_feeds>=rssFeeds.length) {
                    document.getElementById('loading').style.display = "none";
                } else {
                    document.getElementById('loading').innerHTML = "<i>Loading feed "+(1+n_feeds)+" of "+rssFeeds.length+".</i>" 
                }
                return data;
            }

            function updateArticleStyles() {
                const articleContainers = newsFeedContainer.querySelectorAll(".article-container");

                articleContainers.forEach(articleContainer => {
                    const itemId = articleContainer.getAttribute("data-item-id");

                    if (readArticles[itemId]) {
                        articleContainer.classList.add("read-article");
                    } else {
                        articleContainer.classList.remove("read-article");
                    }

                    const upvoteButton = articleContainer.querySelector(".upvote");
                    const downvoteButton = articleContainer.querySelector(".downvote");
                    const skipButton = articleContainer.querySelector(".skip");


                    if (upvotes[itemId]) {
                        upvoteButton.classList.add("thumbs-up");
                    } else {
                        upvoteButton.classList.remove("thumbs-up");
                    }

                    if (downvotes[itemId]) {
                        downvoteButton.classList.add("thumbs-down");
                    } else {
                        downvoteButton.classList.remove("thumbs-down");
                    }

              
                });
            }

            const lookbackSlider = document.getElementById("lookback-slider");
            const lookbackValueElement = document.getElementById("lookback-value");
            
            // Retrieve lookback value from localStorage (if available)
            const savedLookback = localStorage.getItem("lookback") || 14;
            if (savedLookback) {
                lookbackSlider.value = savedLookback;
                lookbackValueElement.textContent = savedLookback;
            }

            // Update lookback value and save to localStorage when slider value changes
            lookbackSlider.addEventListener("input", function () {
                const newLookback = lookbackSlider.value;
                lookbackValueElement.textContent = newLookback;
                localStorage.setItem("lookback", newLookback);
            });

            const toggleModeButton = document.getElementById("toggle-mode");
            const body = document.body;

            // Retrieve dark mode state from localStorage (if available)
            const darkModeState = localStorage.getItem("darkMode");
            if (darkModeState === "enabled") {
                body.classList.add("dark-mode");
                toggleModeButton.innerHTML = "üí°"; // Light bulb emoji
            }

            // Toggle between light and dark mode
            toggleModeButton.addEventListener("click", function () {
                body.classList.toggle("dark-mode");
                if (body.classList.contains("dark-mode")) {
                    localStorage.setItem("darkMode", "enabled");
                    toggleModeButton.innerHTML = "üí°"; // Light bulb emoji
                } else {
                    localStorage.removeItem("darkMode");
                    toggleModeButton.innerHTML = "üåó"; // Moon emoji
                }
            });

            function dedup_articles() {
                var uniqueArticles = [];
                var uniqueArticleIds = new Set();

                articles.reverse().forEach(articleData => {
                    if (!uniqueArticleIds.has(articleData.itemId)) {
                        uniqueArticleIds.add(articleData.itemId);
                        uniqueArticles.push(articleData);
                    } 
                });

                articles = uniqueArticles.reverse();
            }

            function loadNews(loadFeeds = true) {

                const lastLoad = localStorage.getItem("lastLoad") || 0;
                var time_padding = Date.parse(new Date())-300000
                //console.log(lastLoad, time_padding)
                if (lastLoad>time_padding) {
                    loadFeeds = false;
                }

                if (loadFeeds) {

                    localStorage.setItem("lastLoad", Date.parse(new Date()));

                    localStorage.setItem("feeds", JSON.stringify(rssFeeds));
                        
                    newsFeedContainer.innerHTML = "";

                    rssFeeds.forEach(feedUrl => {
                        fetchFeed(feedUrl)
                            .then(data => {
                                const parser = new DOMParser();
                                const xml = parser.parseFromString(data, "application/xml");

                                const feedTitle = xml.querySelector("channel title").textContent;

                                const items = xml.querySelectorAll("item");

                                items.forEach(item => {
                                    //const pubDate = new Date(item.querySelector("pubDate").textContent);
                                    //const lookback = new Date();
                                    //lookback.setDate(lookback.getDate() - 30);

                                    //if (pubDate >= lookback) {
                                        
                                        const title = item.querySelector("title").textContent;
                                        const link = item.querySelector("link").textContent;
                                        const description = item.querySelector("description").textContent;
                                        const pubDate = new Date(item.querySelector("pubDate").textContent);
                                        const image = item.querySelector("image"); // Assuming image tag is present
                                        const mediaContent = item.querySelector("media\\:content, content");
                                        const mediaThumbnail = mediaContent ? mediaContent.getAttribute("url") : null;
                                        const itemId = link; // Using link as a unique identifier for items
                                        const isRead = readArticles[itemId] || false;

                                        // Placeholder function to assign priority rating
                                        const priorityRating = getRating(feedTitle+": "+title+" "+description); 

                                        articles.push({
                                            title,
                                            link,
                                            description,
                                            pubDate,
                                            image: image ? image.textContent : null,
                                            mediaThumbnail,
                                            itemId,
                                            isRead,
                                            feedTitle,
                                            hasUpvote: upvotes[itemId] || false,
                                            hasDownvote: downvotes[itemId] || false,
                                            priorityRating
                                        });
                                    //}
                                });

                                dedup_articles();
                                reorderArticles();
                                displayArticles();
                                updateItemCount();
                            })
                            .catch(error => {
                                // Display a warning popup for error cases
                                const feedTitle = "Unknown Feed";
                                const errorMessage = `Error fetching RSS feed: ${error.message}`;
                                displayErrorPopup(feedTitle, feedUrl, errorMessage);
                            });
                
                    });

                } else {

                    dedup_articles();
                    reorderArticles();
                    displayArticles();
                    updateItemCount();
                }

            }        

            function resetReadStatus() {
                articles.forEach(article => {
                    article.isRead = false;
                });
            }

            function reorderArticles() {
                articles.sort((a, b) => {
                    if (a.isRead && !b.isRead) return 1;
                    if (!a.isRead && b.isRead) return -1;
                    if (a.priorityRating !== b.priorityRating) return b.priorityRating - a.priorityRating;
                    return b.pubDate - a.pubDate;
                });
            }

            function updateOpenButton(card) {
                const openButton = card.querySelector(".read-button");
                if (openButton) {
                    if (card.classList.contains("read-article")) {
                        openButton.classList.remove("btn-secondary");
                        openButton.classList.add("btn-primary");
                        openButton.textContent = "Open";
                    } else {
                        openButton.classList.remove("btn-primary");
                        openButton.classList.add("btn-secondary");
                        openButton.textContent = "View Again";
                    }
                }
            }

            function moveCardToEnd(card) {
                // Move the card to the end of the list
                newsFeedContainer.appendChild(card);

                // Update article styles after the move
                updateArticleStyles();
            }


            function displayArticles() {  

                newsFeedContainer.innerHTML = "";

                articles.forEach((articleData, index) => {

                    const { title, link, description, pubDate, image, mediaThumbnail, itemId, isRead, feedTitle, hasUpvote, hasDownvote, priorityRating } = articleData;

                    const twoWeeksAgo = new Date();
                    twoWeeksAgo.setDate(twoWeeksAgo.getDate() - savedLookback);

                    if (Date.parse(pubDate) >= Date.parse(twoWeeksAgo)) {

                        const article = document.createElement("div");
                        article.setAttribute("data-article-index", index); 
                        article.setAttribute("data-item-id", itemId);
                        article.className = `col-xl-4 col-lg-5 col-md-6 col-sm-12 article-container ${isRead ? 'read-article' : ''}`;
                        article.innerHTML = `
                            <div class="card">
                                <div style="postion:relative:z-index:0;top:0">${mediaThumbnail ? `<img src="${mediaThumbnail}" class="card-img-top thumbnail-image" alt="Thumbnail Image">` : '<img src="images/placeholder.png" class="card-img-top thumbnail-image" alt="Thumbnail Image">'}</div>
                                <div class="card-body">
                                        <!--<div class="priority-rating">${priorityRating}</div>-->
                                        <h5 class="card-title">${title}</h5>
                                        <p class="card-text">${description}</p>
                                        <p class="card-text"><small class="text-muted">${pubDate.toLocaleString()}</small></p>
                                    <div class="d-flex justify-content-between">
                                        <div>
                                            <button class="btn btn-success upvote ${hasUpvote ? 'thumbs-up' : ''}" data-item-id="${itemId}">üëç</button>
                                            <button class="btn btn-danger downvote ${hasDownvote ? 'thumbs-down' : ''}" data-item-id="${itemId}">üëé</button>
                                            <button class="btn btn-secondary skip ${isRead ? 'skip-read' : ''}" data-item-id="${itemId}">Seen</button>
                                        </div>
                                        <a href="${link}" class="btn btn-${isRead ? 'secondary' : 'primary'} read-button" target="_blank">${isRead ? 'View Again' : 'Open'}</a>
                                    </div>
                                </div>
                                <div class="card-footer">
                                    <small class="feed-tag">${feedTitle}</small>
                                </div>
                            </div>
                        `;

                        newsFeedContainer.appendChild(article);

                        const upvoteButton = article.querySelector(".upvote");
                        const downvoteButton = article.querySelector(".downvote");
                        const skipButton = article.querySelector(".skip");
                        const readButton = article.querySelector(".read-button");

                        upvoteButton.addEventListener("click", function() {
                            if (downvotes[itemId]) {
                                delete downvotes[itemId];
                                localStorage.setItem("downvotes", JSON.stringify(downvotes));
                            }
                            
                            if (upvotes[itemId]) {
                                delete upvotes[itemId];
                                localStorage.setItem("upvotes", JSON.stringify(upvotes));
                            } else {
                                upvotes[itemId] = true;
                                localStorage.setItem("upvotes", JSON.stringify(upvotes));
                                //localStorage.setItem("upvotes", JSON.stringify(arr2obj(Object.entries(upvotes).slice(-1))));
                            }
                            
                            updateArticleStyles();
                        });

                        downvoteButton.addEventListener("click", function() {
                            if (upvotes[itemId]) {
                                delete upvotes[itemId];
                                localStorage.setItem("upvotes", JSON.stringify(upvotes));
                            }
                            
                            if (downvotes[itemId]) {
                                delete downvotes[itemId];
                                localStorage.setItem("downvotes", JSON.stringify(downvotes));
                            } else {
                                downvotes[itemId] = true;
                                localStorage.setItem("downvotes", JSON.stringify(downvotes));
                                //localStorage.setItem("downvotes", JSON.stringify(arr2obj(Object.entries(downvotes).slice(-1))));
                            }
                            
                            updateArticleStyles();
                        });

                        skipButton.addEventListener("click", function () {
                            const articleIndex = parseInt(article.getAttribute("data-article-index"));
                            readArticles[itemId] = new Date().toISOString();
                            localStorage.setItem("read", JSON.stringify(readArticles));

                            // Mark the article as read in the articles array
                            articles[articleIndex].isRead = true;

                            // Get the parent container of the clicked skip button
                            const articleContainer = skipButton.closest(".article-container");

                            // Update the Open button behavior
                            updateOpenButton(articleContainer);

                            // Move the article container to the end of the list
                            moveCardToEnd(articleContainer);

                            // Update the unread count
                            updateItemCount();
                        });

                        readButton.addEventListener("click", function() {
                            const articleIndex = parseInt(article.getAttribute("data-article-index"));
                            if (!isRead) {
                                readArticles[itemId] = new Date().toISOString();
                                localStorage.setItem("read", JSON.stringify(readArticles));

                                // Mark the article as read in the articles array
                                articles[articleIndex].isRead = true;

                                // Get the parent container of the clicked skip button
                                const articleContainer = skipButton.closest(".article-container");

                                // Update the Open button behavior
                                updateOpenButton(articleContainer);

                                // Move the article container to the end of the list
                                moveCardToEnd(articleContainer);

                                // Update the unread count
                                updateItemCount();
                            }
                        });
                        
                    }
                });

                // After all articles are displayed, update their styles
                updateArticleStyles();

            }

            function getRating(inputString) {

                const words = inputString.toLowerCase().match(/\b\w+\b/g);
                score = 0;
                for (word in words) {
                    if (isNaN(upTFIDF[words[word]])) {
                        // no action
                    } else {
                        score += upTFIDF[words[word]]*1
                    }
                }
                for (word in words) {
                    if (isNaN(downTFIDF[words[word]])) {
                        // no action
                    } else {
                        score -= downTFIDF[words[word]]*0.5
                    }
                }

                if (score<0){
                    score = 0
                }

                //console.log(score)

                return score;
            }

            function countWords(inputString) {
                const words = inputString.toLowerCase().match(/\b\w+\b/g);

                if (!words) {
                    return {};
                }

                const wordCount = {};
                words.forEach(word => {
                    if (wordCount[word]) {
                        wordCount[word]++;
                    } else {
                        wordCount[word] = 1;
                    }
                });

                return wordCount;
            }

            function countWordsInArray(arrayOfStrings) {
                const wordCount = {};

                arrayOfStrings.forEach(inputString => {
                    const words = inputString.toLowerCase().match(/\b\w+\b/g);

                    if (words) {
                        const uniqueWords = new Set(words);

                        uniqueWords.forEach(word => {
                            if (wordCount[word]) {
                                wordCount[word]++;
                            } else {
                                wordCount[word] = 1;
                            }
                        });
                    }
                });

                return wordCount;
            }

            function extractText(articles) {
                const extractedTexts = [];

                articles.forEach(article => {
                    const { title, description } = article;
                    const extractedText = `${title}\n${description}`;
                    extractedTexts.push(extractedText);
                });

                return extractedTexts;
            }

            function calculateDF(readArticleData) {
                const read_docs = extractText(readArticleData)
                const df = countWordsInArray(read_docs)
                return {"df_arr":df,"n_docs":read_docs.length}
            }

            function calculateTFIDF(votedArticles,df) {

                n_composite_docs = votedArticles.length;
                
                const documents = votedArticles.map(article => article.feedTitle+' '+article.title+' '+article.description);
                const doc = documents.join(' ');

                tf = countWords(doc)

                tf_idf = {}
                if ((df["n_docs"]>100) && (n_composite_docs>10)) {
                    for (const [key, value] of Object.entries(tf)) {
                        if (isNaN(key)) {
                            df["df_arr"][key]=1;
                        }
                        idf = Math.log(1+df["df_arr"][key]/df["n_docs"]);
                        tf_idf[key] = value*idf;
                    }
                }

                return tf_idf;
            }

            function topWords(wordObj) {            

                const pickHighest = (wordObj, num = 1) => {
                    const requiredObj = {};
                    if(num > Object.keys(wordObj).length){
                        return false;
                    };
                    Object.keys(wordObj).sort((a, b) => wordObj[b] - wordObj[a]).forEach((key, ind) =>
                    {
                        if(ind < num){
                            requiredObj[key] = wordObj[key];
                        }
                    });
                    return requiredObj;
                };

                n = 50;
                word_list = pickHighest(wordObj, n)
                if (Object.keys(word_list).length>0) {
                    i = 0
                    words = ""
                    for (word in word_list) {
                        if (i==0){
                            words += " "
                        } else if (i<(n-1)) {
                            words += ", "
                        } else {
                            words += ", &amp; "
                        }
                        words += word
                        i+=1
                    }
                } else {
                    words = "<i>not enough data</i>"
                }

                return words+". "
            }
                    
            function displayErrorPopup(feedTitle, feedUrl, errorMessage) {
                const errorModal = `
                    <div class="modal fade" id="errorModal" tabindex="-1" aria-labelledby="errorModalLabel" aria-hidden="true">
                        <div class="modal-dialog">
                            <div class="modal-content">
                                <div class="modal-header">
                                    <h5 class="modal-title" id="errorModalLabel">Error Fetching Feed</h5>
                                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                                </div>
                                <div class="modal-body">
                                    <p><strong>Feed:</strong> ${feedTitle}</p>
                                    <p><strong>Feed URL:</strong> ${feedUrl}</p>
                                    <p><strong>Error Message:</strong> ${errorMessage}</p>
                                    <p>If this error persists, you can remove this feed using the "My Feeds" button.</p>
                                </div>
                                <div class="modal-footer">
                                    <button id="manage-feeds" class="btn btn-primary" style="width:100%" onClick="window.open('https://github.com/colarusso/rss_algo/tree/main#troubleshooting');">Troubleshoot this error</button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;

                document.body.insertAdjacentHTML("beforeend", errorModal);

                const errorModalElement = document.getElementById("errorModal");
                errorModalElement.addEventListener("hidden.bs.modal", function() {
                    errorModalElement.remove();
                });

                new bootstrap.Modal(errorModalElement).show();
            }

            function filterOldEntries(entries) {
                
                const currentDate = new Date();
                const twoWeeksAgo = new Date();
                twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 60);

                const filteredEntries = {};

                for (const link in entries) {
                    const entryDate = new Date(entries[link]);
                    if (entryDate >= twoWeeksAgo) {
                        filteredEntries[link] = entries[link];
                    }
                }

                return filteredEntries;
            }

            function countUnreadArticles() {
                const cardElements = document.querySelectorAll(".article-container");
                let unreadCount = 0;
                cardElements.forEach(card => {
                    if (!card.classList.contains("read-article")) {
                        unreadCount++;
                    }
                });
                return unreadCount;
            }

            function updateItemCount() {
                const readCount = Object.keys(readArticles).length;
                const unreadCount = countUnreadArticles(); 
                const readCountElement = document.getElementById("read-count");
                const unreadCountElement = document.getElementById("unread-count");
                readCountElement.textContent = `Seen: ${readCount}+`;
                unreadCountElement.textContent = `Unread: ${unreadCount}`;

                var readArticleData = articles.filter(article => readArticles[article.itemId]);
                var upvotedArticleData = articles.filter(article => upvotes[article.itemId]);
                var downvotedArticleData = articles.filter(article => downvotes[article.itemId]);
                let dfreq = calculateDF(readArticleData)
                let upTFIDF = calculateTFIDF(upvotedArticleData,dfreq);
                let downTFIDF = calculateTFIDF(downvotedArticleData,dfreq);

                localStorage.setItem("upTFIDF", JSON.stringify(upTFIDF));
                localStorage.setItem("downTFIDF", JSON.stringify(downTFIDF));

                document.getElementById('upwords').innerHTML = topWords(upTFIDF);
                document.getElementById('downwords').innerHTML = topWords(downTFIDF);

                //console.log("TF-IDF: "+readArticleData.length+" 'read' documents","\nUp: "+upvotedArticleData.length+" documents, "+Object.keys(upTFIDF).length+" words","\nDown: "+downvotedArticleData.length+" documents, "+Object.keys(downTFIDF).length+" words\n");

                localStorage.setItem("articles", JSON.stringify(articles.slice(-1000)));
            }

            const clearUpvotesButton = document.getElementById("clear-upvotes");
            clearUpvotesButton.addEventListener("click", function() {
                // Clear the "read" key from localStorage
                localStorage.removeItem("upvotes");

                // Clear the read status of all articles in the upvotes object
                for (var member in upvotes) delete upvotes[member];

                // Update article styles and the feed list
                updateFeedList();            
            });

            const clearDownvotesButton = document.getElementById("clear-downvotes");
            clearDownvotesButton.addEventListener("click", function() {
                // Clear the "read" key from localStorage
                localStorage.removeItem("downvotes");

                // Clear the read status of all articles in the downvotes object
                for (var member in downvotes) delete downvotes[member];

                // Update article styles and the feed list
                updateFeedList();
            });

            const clearReadHistoryButton = document.getElementById("clear-read-history");
            clearReadHistoryButton.addEventListener("click", function() {
                // Clear the "read" key from localStorage
                localStorage.removeItem("read");

                // Clear the read status of all articles in the readArticles object
                for (var member in readArticles) delete readArticles[member];

                articles = [];
                localStorage.setItem("articles", JSON.stringify(articles));
                let lastLoad = 0;
                localStorage.setItem("lastLoad", 0);

                //resetReadStatus();

                // Reorder the articles to reflect the changes
                //reorderArticles();

                // Update article styles and the feed list
                updateFeedList(true);
            });            
            
            loadNews(true);

            const addFeedButton = document.getElementById("add-feed");
            const manageFeedsButton = document.getElementById("manage-feeds");

            addFeedButton.addEventListener("click", function() {
                const newFeedUrl = prompt("Enter a new RSS feed URL:");
                if (newFeedUrl) {
                    let lastLoad = 0;
                    localStorage.setItem("lastLoad", 0);
                    rssFeeds.push(newFeedUrl);
                    updateFeedList(true);
                }
            });

            manageFeedsButton.addEventListener("click", function() {
                const feedList = rssFeeds.map((feed, index) => `
                        <tr><td>
                        <button class="btn btn-danger remove-feed" data-feed-index="${index}">Remove</button>
                        </td><td>
                        ${feed}</td></tr>
                `).join("");

                const feedListModal = `
                    <div class="modal fade" id="feedListModal" tabindex="-1" aria-labelledby="feedListModalLabel" aria-hidden="true">
                        <div class="modal-dialog">
                            <div class="modal-content">
                                <div class="modal-header">
                                    <h5 class="modal-title" id="feedListModalLabel">My Feeds</h5>
                                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                                </div>
                                <div class="modal-body">
                                    <p>Note: If you remove a feed, old articles will remain on your timeline and in your history.</p>
                                    <table cellpadding="10px">${feedList}</table>
                                </div>
                            </div>
                        </div>
                    </div>
                `;

                document.body.insertAdjacentHTML("beforeend", feedListModal);

                const feedListModalElement = document.getElementById("feedListModal");
                feedListModalElement.addEventListener("hidden.bs.modal", function() {
                    feedListModalElement.remove();
                });

                feedListModalElement.querySelector(".modal-body").addEventListener("click", function(event) {
                    if (event.target.classList.contains("remove-feed")) {
                        const feedIndex = event.target.getAttribute("data-feed-index");
                        rssFeeds.splice(feedIndex, 1);
                        updateFeedList(true);
                        feedListModalElement.querySelector("table").innerHTML = rssFeeds.map((feed, index) => `
                            <tr><td>
                            <button class="btn btn-danger remove-feed" data-feed-index="${index}">Remove</button>
                            </td><td>
                            ${feed}</td></tr>
                        `).join("");
                    }
                });

                new bootstrap.Modal(feedListModalElement).show();
            });
        });

        
     
    </script>
    
</body>
</html>
