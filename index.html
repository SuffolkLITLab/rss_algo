<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>My RSS Algo</title>
	<meta property="og:site_name" content="My RSS Algo"/>
	<meta property="og:type" content="website"/>
	<meta property="og:title" content="RSS Algo"/>
	<meta property="og:description" content="An open source client-side algorithmically-driven RSS reader, living with your data on your device."/>
    <meta property="og:image" content="https://suffolklitlab.org/images/thefuture.png"/>

    <link rel="apple-touch-icon" href="https://suffolklitlab.org/images/icon_300.png"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <style>
        /* Your custom styles can go here */
        .menu {
            float:right;
        }
        .read-article .card {
            opacity: 0.5; /* Slightly transparent for read items */
        }
        .read-article .skip {
            display:none;
        }
        .read-article .card-title,
        .read-article .card-text,
        .read-article .feed-tag {
            color: black; /* Standard black text for read items */
        }
        .article-container {
            margin-bottom: 15px;
        }
        .card-title {
            float:left;
            width:100%;
        }

        .feed-tag {
            font-size: 12px;
            color: #fff0f0;
        }
        .upvote {
            background: rgb(212, 255, 212)
        }
        .downvote {
            background: rgb(255, 216, 216);
        }
        .thumbs-up {
            background: green
        }
        .thumbs-down {
            background: red;
        }
        .priority-rating {
            font-size: 18px;
            margin-right: 5px;
            float:left;
            width:100%;
        }
        #read-count,
        #unread-count {
            font-weight: bold;
            margin-right: 10px;
        }
        .thumbnail-image {
            object-position: center 33%;
            max-height: 200px;
            object-fit: cover;
        }

        .row-equal-height {
            display: flex;
            flex-wrap: wrap;
        }

        .card {
            display: flex;
            flex-direction: column;
            height: 100%; /* Make the card grow to the full height of its container */
        }
        .pocket_share{
            position: absolute;
            top: 5px;
            right: 5px;
            z-index:100;
        }
        .pocket_share a {
            text-decoration: none;
        }
        .masto_share{
            position: absolute;
            top: 5px;
            right: 50px;
            z-index:100;
        }
        .masto_share a {
            padding: 0.2rem 0.6rem 0.3rem;
            background: #6c757d;
            color: white !important;
            border-radius: 0.3rem;
            text-decoration: none;
            font-weight: normal;
            font-size: 13px;
            opacity: 0.66;
        }
        #unread-count {
            padding: 0.2rem 0.6rem 0.3rem;
            background: #db1818;
            color: white !important;
            border-radius: 0.3rem;
            text-decoration: none;
            font-weight: bold;
            font-size: 13px;
            margin-right: 3px;
        }
        #read-count {
            padding: 0.2rem 0.6rem 0.3rem;
            background: #109f08;
            color: white !important;
            border-radius: 0.3rem;
            text-decoration: none;
            font-weight: bold;
            font-size: 13px;
        }
        .card-body {
            flex: 1; /* Allow the card body to grow and fill the remaining space */
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* Space between the title and other elements */
        }

        .card-title {
            font-size: 1.25rem; /* Larger font size for the title */
            margin-bottom: 0.5rem; /* Add some spacing below the title */
        }

        .card-text {
            flex-grow: 1; /* Allow the description to expand to fill space */
            margin-bottom: 1rem; /* Add spacing at the bottom of the description */
        }

        .feed-tag {
            color: black;
            margin-top: auto; /* Push the feed tag to the bottom of the card */
        }

        .btn-group {
            margin-top: auto; /* Push the button group to the bottom of the card */
        }
        .my-1 {
            font-size: 35px;
            line-height: 30px;
            margin-bottom: 20px;
        }
        .btn-block{
            width:100%;
            margin-bottom: 12px;
        }
        .card-footer {
            line-height: 18px;
            width:100%;
            display: flex;
        }
        .remove_all {
            margin: 0 5px 10px 0;
        }
        .remove_feed {
            margin: 0 0 3px auto;
            padding:0;
            font-size: 18px;
            line-height: 18px;
            height: 18px;
        }
        
        
        .highlighted {
            background: yellow;
        }
        .footer {
            border-top: 1px solid #555;
            margin: 20px 0 75px 0;
            padding: 10px 5px;
        }
        #footer_logo_long {
            height:35px;
        }
        #footer_logo_sqr {
            display:none;
            height:35px;
        }

        @media only screen and (max-width: 520px) {
            #footer_logo_long {
                display:none;
            }
            #footer_logo_sqr {
                display:block;
            }
        }
        @media only screen and (max-width: 450px) {
            .menu {
                width:100%;
                text-align:right;
                margin-bottom: 15px;
            }
        }
        
        /* Dark mode styles */
        .dark-mode {
            background-color: #333;
            color: #fff;
        }
        .dark-mode a {
            color: #88e3ff;
        }
        .dark-mode .modal-content {
            background-color: #333;
            color: #fff;
        }
        .dark-mode .btn-close {
            background-image: url('data:image/svg+xml,%3csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="%23FFF"%3e%3cpath d="M.293.293a1 1 0 0 1 1.414 0L8 6.586 14.293.293a1 1 0 1 1 1.414 1.414L9.414 8l6.293 6.293a1 1 0 0 1-1.414 1.414L8 9.414l-6.293 6.293a1 1 0 0 1-1.414-1.414L6.586 8 .293 1.707a1 1 0 0 1 0-1.414z"/%3e%3c/svg%3e');
        }        
        .dark-mode .btn-primary {
            color: #ffffff;
        }
        .dark-mode .card {
            background-color: #333;
            border-color: #4e4e4e;
            color: #fff;
        }               
        .dark-mode .text-muted {
            color: #6a6a6a !important;
        }     
        .dark-mode .card-footer {
            background-color: #4e4e4e;
        }  
        .dark-mode .feed-tag {
            color: #fff;
        }  
        .dark-mode .read-article .card {
            opacity: 0.6;
        }
        .dark-mode .highlighted {
            background: rgb(200, 95, 29);
        }
        .dark-mode .read-article .card-title,
        .dark-mode .read-article .card-text,
        .dark-mode .read-article .feed-tag {
            color: #ccc;
        }
    </style>

    <script>
        var max_arts = 1200;
        function report() {
            new_check = 5000;
            if (localStorage.lastLoad) {
                console.log("Last Sync: "+((Date.parse(new Date) - localStorage.lastLoad)/60000).toFixed(2)+" min. ago")
            }
            if (localStorage.cooldown) {
                console.log("Cooldown: "+localStorage.cooldown+" hours")
            }
            if (localStorage.read) {
                console.log("Read Cards: "+Object.keys(JSON.parse(localStorage.read)).length)
                //console.log(localStorage.read)
            }
            if (localStorage.upvotes) {
                console.log("Upvotes: "+Object.keys(JSON.parse(localStorage.upvotes)).length)
            }
            if (localStorage.downvotes) {
                console.log("Downvotes: "+Object.keys(JSON.parse(localStorage.downvotes)).length)
            }
            console.log("MEMORY REPORT");
            var _lsTotal = 0,
            _xLen, _x;
            for (_x in localStorage) {
                if (!localStorage.hasOwnProperty(_x)) {
                    continue;
                }
                _xLen = ((localStorage[_x].length + _x.length) * 2);
                _lsTotal += _xLen;
                if (new_check) {
                    console.log(" - " + _x.substr(0, 50) + " = " + (_xLen / 1024).toFixed(2) + " KB")
                }
            };
            kbs = (_lsTotal / 1024).toFixed(2)
            percentage = (_lsTotal / 1024).toFixed(2)/new_check	
            console.log("Memory Check: " + Math.round(percentage*10000)/100 + "% (" + kbs + "KB/" + new_check + "KB)");
            if (localStorage.articles) {
                stored_art = JSON.parse(localStorage.articles).length
                console.log("Stored Articles: "+stored_art)
                if (stored_art>100) {
                    try {
                        _xLen = ((localStorage["articles"].length + "articles".length) * 2);
                        size = (_xLen / 1024)/stored_art; // size per article in stored articles 
                        tfidf_size = ((localStorage["upTFIDF"].length + "upTFIDF".length) * 2)/1024/Object.keys(JSON.parse(localStorage.upvotes)).length;
                        size_per_art = (0.2+(0.30+tfidf_size)*1.7+size*1.5); // (size_votes_item + (size_read_item + size_TFIDF)*kept + sizer_per_stored_article*padding)
                        max_arts = Math.round((5000*0.95-100-0.1*JSON.parse(localStorage.feeds).length)/size_per_art)  // 95% default size - 100 for all settings - 0.1 per feed                        
                    } catch (error) {}
                    console.log("Article Cap: "+max_arts);
                }
            } else {
                stored_art = 0
            }
            if (localStorage.feeds) {                
                console.log("Feeds ("+Object.keys(JSON.parse(localStorage.feeds)).length+")");//,JSON.parse(localStorage.feeds));
                //for (feed in JSON.parse(localStorage.feeds)){
                //    console.log("- "+JSON.parse(localStorage.feeds)[feed]);
                //}
            }
        }

        report();
    </script>

    </head>
<body>
    <div class="container">
        <div style="float:left;width:100%;margin-top: 20px;">
            <div class="menu">
                <button id="toggle-mode" class="btn btn-secondary" aria-label="Toggle Dark Mode">🌗</button>
                <!--<button id="math" class="btn btn-secondary">❤️ + Math</button>-->
                <button id="manage-feeds" class="btn btn-secondary">My Feeds</button>
                <button id="add-feed" class="btn btn-primary">+</button>
            </div>
            <div style="float:left;"><h1 class="my-1">My RSS Algo</h1></div>
            <div style="float:left;width:100%;padding-top: 8px;">An open source client-side algorithmically-driven <a href="https://en.wikipedia.org/wiki/RSS" target="_blank">RSS</a> reader made at the <a href="https://suffolklitlab.org/" target="_blank">Suffolk LIT Lab</a>. Use 👍 &amp; 👎 + "Seen" or "Open" to feed the algo. Votes don't leave your device. Customize the algo's behavior in <i>Settings &amp; Data</i>. Curate your feeds using the buttons above. For project updates follow <a href="https://mastodon.social/deck/tags/suffolkrssalgo" target="_blank">#SuffolkRSSalgo</a> on Mastodon, or check out <a href="https://github.com/colarusso/rss_algo" target="_blank">our GitHub page</a>. </div>
            <span id="loading" style="float:left;background:yellow;display:none;margin-right: 10px;color:black;margin-top: 10px;"><i>&nbsp;Loading...&nbsp;</i></span>
        <div class="my-3" style="float:left;width:100%;">
            <span style="float:right"><a id="a_settings" href="javascript:void('')" onClick="toggle_settings()">Settings &amp; Data</a></span>
            <span id="unread-count" class="text-danger">New: ?</span>
            <span id="read-count" class="text-success">Seen: ?</span>
        </div>
        </div>
        <div id="news-feed" class="row">
            <!-- News articles will be dynamically added here -->
        </div>
        </div>            

        <div id="my_settings" class="container" style="display:none;">
            <a name="settings"></a>
            <h2>Settings &amp; Data</h2>
            <p>You can manage your feeds by clicking "My Feeds" at the <a href="javascript:void('')" onClick="history.replaceState('', document.title, window.location.pathname);window.scrollTo(0, 0);">top</a> of this page. See additional controls below. To determine what articles you like, we make use of insights from <a href="https://en.wikipedia.org/wiki/Tf%E2%80%93idf" target="_blank">TF-IDF</a>, comparing all the text from the cards you vote up or down with everything you've "seen." I hope to write a more complete explanation sometime. When I do, I'll put a link here. Until then, you can always look at <a href="https://github.com/colarusso/rss_algo" target="_blank">the code</a>.</p>
            <p><i>Note: when figuring out what you "like" we look only at the card's title, description, and the RSS Feed's name. We don't look at the content of the article, and we also compress all feed titles into single words. That's why you might see things like nyttopstories (NYT > Top Stories) in the word lists below.</i></p>
            <h4>Cooldown Clock</h4>
                    <p>
                    There's no need to download every feed every time you hit refresh. So this site waits a defined period before downloading content. If you refresh the page before the end of this cooldown period, it will recalculate ratings based on recent votes and filter what it displays based on the other options here, but it won't try to download your feeds. Currently the period is set to <b><i><span id="cooldown-value">0.25</span></i> hours</b>. <i>You can change this below, but you must refresh the page to see results. <span class="highlighted"><b>If you set a cooldown period that is shorter than the current value, you will have to wait for the old period to pass before the new one takes effect. So, once you set it and refresh, there's no quickly going back.</b></span></i>
                    </p>
                    <p>
                        <input type="range" id="cooldown-slider" min="0.25" max="4" value="0.25" step="0.25" style="width:100%;">
                    </p>
            <h4>A Note on Performance</h4>
                <p>The options you choose below will effect this site's performance. Generally speaking, the more inclusive your choices the larger your timeline will be and the slower it will load, reorder, and the like. Of course, the number of feeds you follow will also influence this. The trick is finding the right balance for you and your device.</p>
            <h4>Images</h4>
                    <p>
                        <label for="ignore-images"><input type="checkbox" id="ignore-images" value="1"> Ignore preview images (i.e., load w/o thumbnails). <i>Refresh page to see results</i>.</label>
                    </p>
            <h4>Ratings Cutoff</h4>
                <p>
                    After the recommendations kick in, each of your cards is given a rating which is used to order the above list. We also truncate the list based on the following cutoff value. We use the <a href="https://en.wikipedia.org/wiki/Standard_score" target="_blank">z-score</a> of the rating. The z-score of a value is just the number of standard deviations it is away from the mean (average). So the average score of your cards is always 0. Negative numbers are below average, and positive numbers are above average. 
                </p>
                    <p>
                    Z-Score for cutoff: <b><i><span id="cutoff-value">-2.5</span></i></b>. <i>Refresh page to see results</i>.
                    </p>
                    <p>
                        <input type="range" id="cutoff-slider" min="-3.5" max="3.5" value="-2.5" step="0.01" style="width:100%;">
                    </p>
            <h4>Positive vs. Negative</h4>
                <p></p>
                    <p>
                    When calculating ratings, how much influence should <i>down votes</i> have compared to <i>up votes</i>? If you choose 0, they don't count at all. If you choose 2, they'll count twice as much as <i>up votes</i>. Current value: <b><i><span id="negativity-value">1.25</span></i></b>. <i>Refresh page to see results</i>.
                    </p>
                    <p>
                        <input type="range" id="negativity-slider" min="0" max="2" value="1.25" step="0.01" style="width:100%;">
                    </p>
            <div class="row">
                <div class="col-xl-4 col-lg-5 col-md-6 col-sm-12 col-md-4" style="overflow:hidden;">
                    <h4>Positive</h4>
                    <p>Here are your <b><i>most-positive</i></b> words and their approximate TF-IDF, treating all up-voted cards as a single document: <span id="upwords">not enough data</span></p>
                    <button id="clear-upvotes" class="btn btn-danger btn-block">Clear Upvotes</button>
                </div>
                <div class="col-xl-4 col-lg-5 col-md-6 col-sm-12 col-md-4" style="overflow:hidden;">
                    <h4>Negative</h4>
                    <p>Here are your <b><i>most-negative</i></b> words and their approximate TF-IDF, treating all down-voted cards as a single document: <span id="downwords">not enough data</span></p>
                    <button id="clear-downvotes" class="btn btn-danger btn-block">Clear Downvotes</button>
                </div>
                <div class="col-xl-4 col-lg-5 col-md-6 col-sm-12 col-md-4">
                    <h4>History</h4>
                    Display content from the last <b><i><span id="lookback-value">7</span> days</i></b>. <i>Refresh page to see results</i>.
                    <p>
                        <input type="range" id="lookback-slider" min="1" max="15" value="7" style="width:100%;">
                    </p>
                    <p>You can limit how much you see in your timeline by adjusting the slider above. If you clear you reading history, however, it will remove older articles, not just hide them. This will effect your recommendations since they are based on interactions with old articles.</p>
                    <button id="clear-read-history" class="btn btn-danger btn-block">Clear Reading History</button>
                    <button id="factory-reset" class="btn btn-danger btn-block factory-reset" onClick="reset_all();"><b>RESET ALL</b></button>
                </div>
                <h4>Mastodon</h4>
                <p>Since users of <a href="https://joinmastodon.org/" target="_blank">Mastodon</a> use different servers/instnaces, we need to collect that information to enable sharing (i.e., so we can queue your post on the right server). If you'd like to use this feature, enter your server here:</p>
                <p><input id="masto_instance" value="" oninput="localStorage.instance=this.value"></p>
        </div>
    </div>
    <div class="container">
        <div class="footer">
            <a href="https://suffolklitlab.org/" alt="LIT Lab" target="_blank">
                <img id="footer_logo_long" src="images/lit_suffolk.png" border="0" height="35px" alt="LIT and Suffolk University Law School Logos" align="left"/>
                <img id="footer_logo_sqr" src="images/blue_logo.png" border="0" alt="LIT and Suffolk University Law School Logos" align="left"/>
            </a>
            <span style="float:right">
                <a href="https://github.com/colarusso/rss_algo" target="_blank">GitHub Repo</a>
            </span>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.js"></script>
    <script>

        history.replaceState('', document.title, window.location.pathname);window.scrollTo(0, 0);

        function toggle_settings() {
            if (document.getElementById('my_settings').style.display=="none") {
                document.getElementById('news-feed').style.display = "none";
                document.getElementById('my_settings').style.display = "block";
                document.getElementById('a_settings').innerHTML = "Show Timeline";
            } else {
                document.getElementById('my_settings').style.display = "none";
                document.getElementById('news-feed').style.display = "flex";
                document.getElementById('a_settings').innerHTML = "Settings &amp; Data";
            }
        }

        function readArticles_in_window(){
            articls_in_window = 0
            JSON.parse(localStorage.articles).forEach(card => {
                if (Date.parse(card.pubDate)>(new Date()-(1*60000*60*60*24))) {
                    articls_in_window++;
                }
            });
            return articls_in_window
        }

        function save_to_poeket(url){
            var win = window.open( "https://getpocket.com/edit?url="+ encodeURIComponent(url), "pocket" );
            //setTimeout( function() {
            //    win.close();
            //}, 1000);
        }
            
        /* Generate a share link for the user's Mastodon domain */
        const instance =  localStorage.getItem("instance") || "";
        document.getElementById("masto_instance").value = instance;

        function MastodonShare(target){

            if ( document.getElementById("masto_instance").value=="") {
                my_instance = "mastodon.social"
                // Get the Mastodon domain
                domain = prompt("Enter your Mastodon domain. If you want to change this later, you can do so in 'Settings.'", my_instance);
            } else {
                my_instance = document.getElementById("masto_instance").value
                domain = my_instance
            }

            if (domain == "" || domain == null){
                return;
            }

            domain = domain.replace(/https?:\/\//,"")

            localStorage.instance = domain;
            document.getElementById("masto_instance").value = domain;

            // Build the URL
            url = "https://" + domain + "/share?text=" + target;

            // Open a window on the share page
            window.open(url, '_blank');
        }

        function reset_all() {
            let text = "This will erase all of your data and set the list of feeds to defaults. Choose OK to continue.";
            if (confirm(text) == true) {
                history.replaceState('', document.title, window.location.pathname);
                localStorage.clear();
                sessionStorage.clear();
                window.location.reload(true);
            }
        }

        document.addEventListener("DOMContentLoaded", function() {

            const toggleModeButton = document.getElementById("toggle-mode");
            const body = document.body;

            // Retrieve dark mode state from localStorage (if available)
            const darkModeState = localStorage.getItem("darkMode");
            if (darkModeState === "enabled") {
                body.classList.add("dark-mode");
                toggleModeButton.innerHTML = "💡"; // Light bulb emoji
            }

            // Toggle between light and dark mode
            toggleModeButton.addEventListener("click", function () {
                body.classList.toggle("dark-mode");
                if (body.classList.contains("dark-mode")) {
                    localStorage.setItem("darkMode", "enabled");
                    toggleModeButton.innerHTML = "💡"; // Light bulb emoji
                } else {
                    localStorage.removeItem("darkMode");
                    toggleModeButton.innerHTML = "🌗"; // Moon emoji
                }
            });

            const default_feeds = [
                "https://rss.nytimes.com/services/xml/rss/nyt/World.xml",
                "https://rss.nytimes.com/services/xml/rss/nyt/US.xml",
                "https://rss.nytimes.com/services/xml/rss/nyt/Technology.xml",
                "https://rss.nytimes.com/services/xml/rss/nyt/Science.xml",
                "https://rss.nytimes.com/services/xml/rss/nyt/Space.xml",
                "https://rss.nytimes.com/services/xml/rss/nyt/Arts.xml",
                "http://feeds.washingtonpost.com/rss/politics?itid=lk_inline_manual_2",
                "http://feeds.washingtonpost.com/rss/business/technology?itid=lk_inline_manual_31",
                "https://feeds.npr.org/1001/rss.xml",
                "https://feeds.npr.org/1014/rss.xml",
                "https://feeds.npr.org/1007/rss.xml",
                "https://www.economist.com/leaders/rss.xml",
                "https://www.economist.com/briefing/rss.xml",
                "https://www.economist.com/science-and-technology/rss.xml",
                "https://feeds.a.dj.com/rss/WSJcomUSBusiness.xml",
                "http://www.newyorker.com/feed/news",
                "http://www.newyorker.com/feed/culture",
                "http://www.newyorker.com/feed/humor",
                "http://www.newyorker.com/feed/tag/books/rss",
                "http://www.newyorker.com/feed/tech",
                "http://www.newyorker.com/feed/news/sporting-scene",
                "https://feeds.arstechnica.com/arstechnica/features",
                "https://feeds.arstechnica.com/arstechnica/technology-lab",
                "https://feeds.arstechnica.com/arstechnica/tech-policy",
                "https://feeds.arstechnica.com/arstechnica/science",
                "https://www.wired.com/feed/category/science/latest/rss",
                "https://www.wired.com/feed/category/ideas/latest/rss",
                "https://www.wired.com/feed/tag/ai/latest/rss",
                "https://slate.com/feeds/news-and-politics.rss",
                "https://slate.com/feeds/technology.rss",
                "https://slate.com/feeds/business.rss",
                "https://www.lawnext.com/feed",
                "https://patch.com/feeds/aol/massachusetts/boston",
                "https://xkcd.com/rss.xml",
                "https://pluralistic.net/feed/"
                // Add more default RSS feed URLs here
            ]

            let rssFeeds = JSON.parse(localStorage.getItem("feeds")) || default_feeds;

            function arr2obj(arr) {
                return arr.reduce(
                    (acc, curr) => {
            
                        // Extract the key and the value
                        let key = curr[0];
                        let value = curr[1];
            
                        // Assign key and value
                        // to the accumulator
                        acc[key] = value;
            
                        // Return the accumulator
                        return acc;
                    },
            
                    // Initialize with an empty object
                    {}
                );
            }

            const newsFeedContainer = document.getElementById("news-feed");
            const upvotes =  JSON.parse(localStorage.getItem("upvotes")) || {};
            const downvotes = JSON.parse(localStorage.getItem("downvotes")) || {};
            const upTFIDF =  JSON.parse(localStorage.getItem("upTFIDF")) || {};
            const downTFIDF =  JSON.parse(localStorage.getItem("downTFIDF")) || {};
            const readArticles = filterOldEntries(JSON.parse(localStorage.getItem("read")) || {});

            const stopwords = ['i','me','my','myself','we','our','ours','ourselves','you','your','yours','yourself','yourselves','he','him','his','himself','she','her','hers','herself','it','its','itself','they','them','their','theirs','themselves','what','which','who','whom','this','that','these','those','am','is','are','was','were','be','been','being','have','has','had','having','do','does','did','doing','a','an','the','and','but','if','or','because','as','until','while','of','at','by','for','with','about','against','between','into','through','during','before','after','above','below','to','from','up','down','in','out','on','off','over','under','again','further','then','once','here','there','when','where','why','how','all','any','both','each','few','more','most','other','some','such','no','nor','not','only','own','same','so','than','too','very','s','t','can','will','just','don','should','now']

            var articles =  JSON.parse(localStorage.getItem("articles")) || [];
            var dfreq = calculateDF(articles.filter(article => readArticles[article.itemId]))
            var crunch_numbers = false

            var ratings_mean = 0;
            var ratings_std = 0;

            function updateFeedList(loadFeeds = false, singlefeed="") {
                localStorage.setItem("feeds", JSON.stringify(rssFeeds));
                let upTFIDF =  JSON.parse(localStorage.getItem("upTFIDF")) || {};
                let downTFIDF =  JSON.parse(localStorage.getItem("downTFIDF")) || {};
                loadNews(loadFeeds,singlefeed);
                
            }

            var n_feeds = 0;
            async function fetchFeed(feedUrl) {
                document.getElementById('loading').style.display = "block";

                //If forking this repo, please use your own CORS proxy
                feedUrl = "https://tools.suffolklitlab.org/rss_proxy/?url="+encodeURIComponent(feedUrl)
                
                const response = await fetch(feedUrl);
                                
                if (!response.ok) {
                    throw new Error(`Request failed with status ${response.status}`);
                }
                const data = await response.text();
                n_feeds += 1;
                if (n_feeds>=rssFeeds.length) {
                    document.getElementById('loading').style.display = "none";
                } else {
                    document.getElementById('loading').innerHTML = "<i>&nbsp;Loading feed "+(1+n_feeds)+" of "+rssFeeds.length+".&nbsp;</i>" 
                }

                if (n_feeds>=(rssFeeds.length)) {
                    crunch_numbers = true;
                }

                return data;
            }

            function updateArticleStyles() {
                const articleContainers = newsFeedContainer.querySelectorAll(".article-container");

                articleContainers.forEach(articleContainer => {
                    const itemId = articleContainer.getAttribute("data-item-id");

                    if (readArticles[itemId]) {
                        articleContainer.classList.add("read-article");
                    } else {
                        articleContainer.classList.remove("read-article");
                    }

                    const upvoteButton = articleContainer.querySelector(".upvote");
                    const downvoteButton = articleContainer.querySelector(".downvote");
                    const skipButton = articleContainer.querySelector(".skip");


                    if (upvotes[itemId]) {
                        upvoteButton.classList.add("thumbs-up");
                    } else {
                        try {
                            upvoteButton.classList.remove("thumbs-up");
                        } catch (error) {}
                    }

                    if (downvotes[itemId]) {
                        downvoteButton.classList.add("thumbs-down");
                    } else {
                        try {
                            downvoteButton.classList.remove("thumbs-down");
                        } catch (error) {}
                    }

              
                });

            }


            const cooldownSlider = document.getElementById("cooldown-slider");
            const cooldownValueElement = document.getElementById("cooldown-value");
            
            // Retrieve cooldown value from localStorage (if available)
            const savedcooldown = localStorage.getItem("cooldown") || 0.5;
            if (savedcooldown) {
                cooldownSlider.value = savedcooldown;
                cooldownValueElement.textContent = savedcooldown;
            }

            // Update cooldown value and save to localStorage when slider value changes
            cooldownSlider.addEventListener("input", function () {
                const newcooldown = cooldownSlider.value;
                cooldownValueElement.textContent = newcooldown;
                localStorage.setItem("cooldown", newcooldown);
            });

            const lookbackSlider = document.getElementById("lookback-slider");
            const lookbackValueElement = document.getElementById("lookback-value");
            
            // Retrieve lookback value from localStorage (if available)
            const savedLookback = localStorage.getItem("lookback") || 3;
            if (savedLookback) {
                lookbackSlider.value = savedLookback;
                lookbackValueElement.textContent = savedLookback;
            }

            // Update lookback value and save to localStorage when slider value changes
            lookbackSlider.addEventListener("input", function () {
                const newLookback = lookbackSlider.value;
                lookbackValueElement.textContent = newLookback;
                localStorage.setItem("lookback", newLookback);
            });

            const cutoffSlider = document.getElementById("cutoff-slider");
            const cutoffValueElement = document.getElementById("cutoff-value");
            
            // Retrieve cutoff value from localStorage (if available)
            const savedcutoff = localStorage.getItem("cutoff") || -2.5;
            if (savedcutoff) {
                cutoffSlider.value = savedcutoff;
                cutoffValueElement.textContent = savedcutoff;
            }

            // Update cutoff value and save to localStorage when slider value changes
            cutoffSlider.addEventListener("input", function () {
                const newcutoff = cutoffSlider.value;
                cutoffValueElement.textContent = newcutoff;
                localStorage.setItem("cutoff", newcutoff);
            });

            const negativitySlider = document.getElementById("negativity-slider");
            const negativityValueElement = document.getElementById("negativity-value");
            
            // Retrieve negativity value from localStorage (if available)
            const savednegativity = localStorage.getItem("negativity") || 1.25;
            if (savednegativity) {
                negativitySlider.value = savednegativity;
                negativityValueElement.textContent = savednegativity;
            }

            // Update negativity value and save to localStorage when slider value changes
            negativitySlider.addEventListener("input", function () {
                const newnegativity = negativitySlider.value;
                negativityValueElement.textContent = newnegativity;
                localStorage.setItem("negativity", newnegativity);
            });

            const ignoreImagesCheckbox = document.getElementById("ignore-images");

            // Retrieve ignore images value from localStorage (if available)
            const savedIgnoreImages = localStorage.getItem("ignoreImages") === "true";
            ignoreImagesCheckbox.checked = savedIgnoreImages;

            // Update ignore images value and save to localStorage when checkbox value changes
            ignoreImagesCheckbox.addEventListener("change", function () {
                const newIgnoreImages = ignoreImagesCheckbox.checked;
                localStorage.setItem("ignoreImages", newIgnoreImages);
            });


            function dedup_articles() {
                var uniqueArticles = [];
                var uniqueArticleIds = new Set();

                articles.reverse().forEach(articleData => {
                    if (!uniqueArticleIds.has(articleData.itemId)) {
                        uniqueArticleIds.add(articleData.itemId);
                        uniqueArticles.push(articleData);
                    } 
                });

                articles = uniqueArticles.reverse();
            }

            function extractContent(s) {
                var span = document.createElement('span');
                span.innerHTML = s;
                return span.textContent || span.innerText;
            };

            function loadNews(loadFeeds = true, singlefeed="") {

                const lastLoad = localStorage.getItem("lastLoad") || 0;
                const lastcooldown = localStorage.getItem("lastcooldown") || 0.25;

                //console.log("new cooldown",savedcooldown,"old cooldown",lastcooldown)
                
                if (savedcooldown>=lastcooldown) {
                    var time_padding = Date.parse(new Date())-savedcooldown*60*60*1000 //750000
                    localStorage.setItem("lastcooldown", savedcooldown);
                } else {
                    var time_padding = Date.parse(new Date())-lastcooldown*60*60*1000 //750000
                }

                //console.log(lastLoad, time_padding)
                if (lastLoad>time_padding) {
                    loadFeeds = false;
                }

                if (loadFeeds) {

                    localStorage.setItem("lastLoad", Date.parse(new Date()));

                    localStorage.setItem("feeds", JSON.stringify(rssFeeds));
                        
                    newsFeedContainer.innerHTML = "";

                    if (singlefeed.length>0) {
                        n_feeds = rssFeeds.length - 1;
                        use_feeds = [singlefeed];
                    } else {
                        use_feeds = rssFeeds;
                    }

                    use_feeds.forEach(feedUrl => {
                        fetchFeed(feedUrl)
                            .then(data => {

                                //console.log(data)

                                const parser = new DOMParser();
                                const xml = parser.parseFromString(data, "application/xml");

                                //console.log(xml)

                                const feedTitle = xml.querySelector("channel title").textContent;
                                
                                const items = xml.querySelectorAll("item");

                                j=0;
                                items.forEach(item => {
                                    const pubDate = new Date(item.querySelector("pubDate").textContent);
                                    const lookback = new Date();
                                    lookback.setDate(lookback.getDate() - 30);

                                    //console.log(rssFeeds.length)

                                    if ((pubDate >= lookback) && (j<(max_arts/(rssFeeds.length*0.49))) && (pubDate <= new Date())) {
                                        
                                        try {
                                            title = item.querySelector("title").textContent;
                                        } catch (error) {
                                            title = ""
                                        }

                                        const link = item.querySelector("link").textContent;
                                        description = item.querySelector("description").textContent;

                                        const re = /(https?:\/\/[^\s]+\.(?:png|jpg|jpeg|gif))/i;
                                        possible_img = description.match(re)
                                        if (possible_img) {
                                            if (!possible_img[0].match("tracking")) {
                                                possible_img = possible_img[0]
                                            } else if (possible_img[0].match("tracking") && possible_img[1] && !possible_img[1].match("tracking")) {
                                                possible_img = possible_img[1]
                                            } else {
                                                possible_img = null
                                            }
                                        }

                                        description = extractContent(description)

                                        if (description.length>400) {
                                            description = description.slice(0,400)+" [...]";
                                        }

                                        const pubDate = new Date(item.querySelector("pubDate").textContent);
                                        
                                        //const image = item.querySelector("image"); 

                                        //const mediaContent = item.querySelector("media\\:content, content");
                                        //const mediaThumbnail = mediaContent ? mediaContent.getAttribute("url") : null;

                                        try {
                                            mediaThumbnail = item.querySelector("media\\:content, content").getAttribute("url");
                                        } catch(error) {
                                            mediaThumbnail = null
                                        }

                                        if (Object.is(mediaThumbnail, null)) {
                                            mediaContent = item.querySelector("media\\:thumbnail, thumbnail");
                                            if (mediaContent) {
                                                mediaThumbnail = mediaContent.getAttribute("url");
                                            } else {
                                                mediaThumbnail = null
                                            }
                                        }

                                        if (Object.is(mediaThumbnail, null)) {
                                            mediaThumbnail = possible_img
                                        }

                                        if (Object.is(mediaThumbnail, null)) {
                                            try {
                                                blob_of_text = item.querySelector("content\\:encoded, encoded").textContent
                                                possible_img = blob_of_text.match(re)
                                                if (possible_img) {
                                                    if (!possible_img[0].match("tracking")) {
                                                        possible_img = possible_img[0]
                                                    } else if (possible_img[0].match("tracking") && possible_img[1] && !possible_img[1].match("tracking")) {
                                                        possible_img = possible_img[1]
                                                    } else {
                                                        possible_img = null
                                                    }                                                    
                                                    mediaThumbnail = possible_img
                                                }
                                                } catch (error) {}
                                        }                 
                                        
                                        if (Object.is(mediaThumbnail, null)) {
                                            if(link.includes("washingtonpost.com")){
                                                // source: https://www.washingtonpost.com/reprints-permissions/
                                                mediaThumbnail = "https://www.washingtonpost.com/wp-apps/imrs.php?src=https://www.washingtonpost.com/wp-stat/store/newspaper.jpg&w=700&h=525&t=20191113b"
                                            } else if (link.includes("economist.com")) {
                                                // source: https://commons.wikimedia.org/wiki/File:The_Economist_Logo.svg
                                                mediaThumbnail = "https://upload.wikimedia.org/wikipedia/commons/thumb/6/65/The_Economist_Logo.svg/640px-The_Economist_Logo.svg.png"
                                            } else if (link.includes("nytimes.com")) {
                                                // source: https://commons.wikimedia.org/wiki/File:Nytimes_hq.jpg
                                                mediaThumbnail = "https://upload.wikimedia.org/wikipedia/commons/thumb/0/0e/Nytimes_hq.jpg/640px-Nytimes_hq.jpg"
                                            } else if (link.includes("wsj.com")) {
                                                mediaThumbnail = "https://s.wsj.net/img/meta/wsj-social-share.png"
                                            } else if (link.includes("npr.org")) {
                                                // source: https://www.npr.org/about-npr/182675632/photos-and-logos
                                                mediaThumbnail = "https://media.npr.org/assets/img/2019/06/17/nprlogo_rgb_whiteborder_custom-7c06f2837fb5d2e65e44de702968d1fdce0ce748-s1300-c85.webp";
                                            }
                                        }
                                    
                                        const itemId = link; // Using link as a unique identifier for items
                                        const isRead = readArticles[itemId] || false;

                                        const priorityRating = getRating(feedTitle.replace(/[^a-zA-Z]/g,"")+": "+title+" "+description); 

                                        articles.push({
                                            title,
                                            link,
                                            description,
                                            pubDate,
                                            //image: image ? image.textContent : null,
                                            mediaThumbnail,
                                            itemId,
                                            isRead,
                                            feedTitle,
                                            feedUrl,
                                            hasUpvote: upvotes[itemId] || false,
                                            hasDownvote: downvotes[itemId] || false,
                                            priorityRating
                                        });
                                    }
                                    j+=1
                                });

                                dedup_articles();
                                reorderArticles();
                                displayArticles();
                                updateItemCount();
                                if (crunch_numbers) {
                                    displayed_cards = newsFeedContainer.childNodes.length
                                    console.log("Displayed Cards: " +displayed_cards+" ("+Math.round(100*displayed_cards/stored_art)+"%)");
                                    lazyload();
                                }
                            })
                            .catch(error => {
                                // Display a warning popup for error cases
                                const feedTitle = "Unknown Feed";
                                const errorMessage = `Error fetching RSS feed: ${error.message}`;
                                displayErrorPopup(feedTitle, feedUrl, errorMessage);
                            });
                
                    });

                } else {

                    crunch_numbers = true;
                    dedup_articles();
                    reorderArticles();
                    displayArticles();
                    updateItemCount();
                    displayed_cards = newsFeedContainer.childNodes.length
                    console.log("Displayed Cards: " +displayed_cards+" ("+Math.round(100*displayed_cards/stored_art)+"%)");
                    lazyload();
                    crunch_numbers = false;
                }

                crunch_numbers = false;
                
            }        

            function resetReadStatus() {
                articles.forEach(article => {
                    article.isRead = false;
                });
            }

            function reorderArticles() {

                if (crunch_numbers) {
                    tmp_ratings = []
                    for (article in articles){
                        rating = getRating(articles[article]['feedTitle'].replace(/[^a-zA-Z]/g,"")+": "+articles[article]['title']+" "+articles[article]['description'])
                        articles[article]["priorityRating"] = rating; 
                        tmp_ratings.push(rating)
                    }
                    stats = StandardDeviation(tmp_ratings)
                    ratings_mean = stats[0];
                    ratings_std = stats[1];
                    console.log("Ratings: mean", ratings_mean,"std",ratings_std);                    
                }

                articles.sort((a, b) => new Date(a.pubDate) - new Date(b.pubDate));
                //console.log("#",articles)
                keep_last = Math.round(max_arts*1.5);
                articles = articles.slice(-keep_last)

                articles.sort((a, b) => {
                    if (a.isRead && !b.isRead) return 1;
                    if (!a.isRead && b.isRead) return -1;
                    if (a.priorityRating !== b.priorityRating) return b.priorityRating - a.priorityRating;
                    return new Date(b.pubDate) - new Date(a.pubDate);
                });
                
            }

            function updateOpenButton(card) {
                const openButton = card.querySelector(".read-button");
                if (openButton) {
                    if (card.classList.contains("read-article")) {
                        openButton.classList.remove("btn-secondary");
                        openButton.classList.add("btn-primary");
                        openButton.textContent = "Open";
                    } else {
                        openButton.classList.remove("btn-primary");
                        openButton.classList.add("btn-secondary");
                        openButton.textContent = "View Again";
                    }
                }
            }

            function moveCardToEnd(card) {
                // Move the card to the end of the list
                newsFeedContainer.appendChild(card);

                // Update article styles after the move
                updateArticleStyles();
            }

            function domain_from_url(url) {
                var result
                var match
                if (match = url.match(/^(?:https?:\/\/)?(?:[^@\n]+@)?(?:www\.)?([^:\/\n\?\=]+)/im)) {
                    result = match[1]
                    if (match = result.match(/^[^\.]+\.(.+\..+)$/)) {
                        result = match[1]
                    }
                }
                return result
            }


            function displayArticles() {  

                newsFeedContainer.innerHTML = "";

                i=0
                articles.forEach((articleData, index) => {

                    const { title, link, description, pubDate, image, mediaThumbnail, itemId, isRead, feedTitle, feedUrl, hasUpvote, hasDownvote, priorityRating } = articleData;

                    const twoWeeksAgo = new Date();
                    twoWeeksAgo.setDate(twoWeeksAgo.getDate() - savedLookback);

                    if (((i==2 && !isRead) || (i==0 && isRead)) && (Math.random()<=0.1) && ((n_feeds>=rssFeeds.length) || (n_feeds==0))) {

                        if (savedIgnoreImages){
                            img_html = `
                                <div style="postion:relative;z-index:0;top:0;height:33px;"></div>`
                        } else {
                            img_html = `
                                <div style="postion:relative;z-index:0;top:0"><img src="images/sargent.jpg" class="lazyload card-img-top thumbnail-image"></div>`
                        }

                        const sponsor = document.createElement("div");
                        sponsor.setAttribute("data-article-index", "sponsor"); 
                        sponsor.setAttribute("data-item-id", "sponsor");
                        sponsor.className = `col-xl-4 col-lg-5 col-md-6 col-sm-12 article-container`;
                        sponsor.innerHTML = `
                            <div class="card">
                                <div class="masto_share" style="right:10px;"><a href="javascript:void('')" onclick="MastodonShare('Support Suffolk Law\\'s LIT Lab;url=https://suffolklitlab.org/docs/affiliates.pdf');">Mastodon</a></div>
                                ${img_html}
                                <div class="card-body">
                                        <h5 class="card-title">Support the People Who Built <i>My RSS Algo</i>!</h5>
                                        <p class="card-text">Through its Affiliates Program, Suffolk University Law School's Legal Innovation and Technology <a href="https://suffolklitlab.org/" target="_blank">(LIT) Lab</a> provides members with connections to experts and law students working with emerging legal services technologies, while growing the Lab's capacity to serve disadvantaged communities.</p>
                                    <div style="text-align:right;">
                                        <a href="https://suffolklitlab.org/docs/affiliates.pdf" class="btn btn-primary" target="_blank">Become an Affiliate</a>
                                    </div>
                                </div>
                                <div class="card-footer">
                                    <small class="feed-tag">FROM THE MAKERS OF THIS SITE</small>
                                </div>
                            </div>
                        `;                        
                        newsFeedContainer.appendChild(sponsor);
                        i+=1;
                    }


                    if ((Date.parse(pubDate) >= Date.parse(twoWeeksAgo)) && priorityRating >= ratings_mean+ratings_std*(savedcutoff)) {

                        const article = document.createElement("div");
                        article.setAttribute("data-article-index", index); 
                        article.setAttribute("data-item-id", itemId);
                        article.className = `col-xl-4 col-lg-5 col-md-6 col-sm-12 article-container ${isRead ? 'read-article' : ''}`;

                        local_pubDate = new Date(pubDate).toLocaleString();

                        domain_for_img = domain_from_url(link);

                        if (savedIgnoreImages){
                            img_html = `
                                <div style="postion:relative;z-index:0;top:0;height:33px;"></div>`
                        } else {
                            img_html = `
                                <div style="postion:relative;z-index:0;top:0">${mediaThumbnail ? `<img data-src="${mediaThumbnail}" class="lazyload card-img-top thumbnail-image">` : '<img data-src="images/placeholder.png" class="lazyload card-img-top thumbnail-image">'}</div>`
                        }

                        article.innerHTML = `
                            <div class="card">
                                <div class="masto_share"><a href="javascript:void('')" onclick="MastodonShare(\`${title};url=${link}\`);">Mastodon</a></div>
                                <div class="pocket_share"><a href="javascript:void('')" onClick="save_to_poeket(\`${link}\`)"><div style="background: url('https://getpocket.com/i/v3/pocket_logo.png');background-position: 0px -9px; width:35px;height:40px;"></div></a></div>
                                ${img_html}
                                
                                <div class="card-body">
                                        <!--<div class="priority-rating">${priorityRating}</div>-->
                                        <h5 class="card-title">${title}</h5>
                                        <p class="card-text">${description}</p>
                                        <p class="card-text"><small class="text-muted">${local_pubDate}</small></p>
                                    <div class="d-flex justify-content-between">
                                        <div>
                                            <button class="btn btn-success upvote ${hasUpvote ? 'thumbs-up' : ''}" data-item-id="${itemId}">👍</button>
                                            <button class="btn btn-danger downvote ${hasDownvote ? 'thumbs-down' : ''}" data-item-id="${itemId}">👎</button>
                                            <button class="btn btn-secondary skip ${isRead ? 'skip-read' : ''}" data-item-id="${itemId}">Seen</button>
                                        </div>
                                        <div>
                                        <a href="${link}" class="btn btn-${isRead ? 'secondary' : 'primary'} read-button" target="_blank">${isRead ? 'View Again' : 'Open'}</a>
                                        </div>
                                    </div>
                                </div>
                                <div class="card-footer">
                                    <img src="https://${domain_for_img}/favicon.ico" height="18px" align="left/> <small class="feed-tag">&nbsp;&nbsp;${feedTitle}</small> 
                                    <span class="btn remove_feed" data-feed-index="${feedUrl}" data-feed-name="${feedTitle}">🚫</span>
                                </div>
                            </div>
                        `;

                        newsFeedContainer.appendChild(article);

                        const upvoteButton = article.querySelector(".upvote");
                        const downvoteButton = article.querySelector(".downvote");
                        const skipButton = article.querySelector(".skip");
                        const readButton = article.querySelector(".read-button");

                        upvoteButton.addEventListener("click", function() {
                            if (downvotes[itemId]) {
                                delete downvotes[itemId];
                                localStorage.setItem("downvotes", JSON.stringify(downvotes));
                            }
                            
                            if (upvotes[itemId]) {
                                delete upvotes[itemId];
                                localStorage.setItem("upvotes", JSON.stringify(upvotes));
                            } else {
                                upvotes[itemId] = true;
                                localStorage.setItem("upvotes", JSON.stringify(upvotes));
                            }
                            localStorage.setItem("upvotes", JSON.stringify(arr2obj(Object.entries(upvotes).slice(-max_arts))));
                            
                            updateArticleStyles();
                        });

                        downvoteButton.addEventListener("click", function() {
                            if (upvotes[itemId]) {
                                delete upvotes[itemId];
                                localStorage.setItem("upvotes", JSON.stringify(upvotes));
                            }
                            
                            if (downvotes[itemId]) {
                                delete downvotes[itemId];
                                localStorage.setItem("downvotes", JSON.stringify(downvotes));
                            } else {
                                downvotes[itemId] = true;
                                localStorage.setItem("downvotes", JSON.stringify(downvotes));
                            }
                            localStorage.setItem("downvotes", JSON.stringify(arr2obj(Object.entries(downvotes).slice(-max_arts))));
                            
                            updateArticleStyles();
                        });

                        skipButton.addEventListener("click", function () {
                            const articleIndex = parseInt(article.getAttribute("data-article-index"));
                            readArticles[itemId] = new Date().toISOString();
                            localStorage.setItem("read", JSON.stringify(readArticles));

                            // Mark the article as read in the articles array
                            articles[articleIndex].isRead = true;

                            // Get the parent container of the clicked skip button
                            const articleContainer = skipButton.closest(".article-container");

                            // Update the Open button behavior
                            updateOpenButton(articleContainer);

                            // Move the article container to the end of the list
                            moveCardToEnd(articleContainer);

                            // Update the unread count
                            updateItemCount();
                        });

                        readButton.addEventListener("click", function() {
                            const articleIndex = parseInt(article.getAttribute("data-article-index"));
                            if (!isRead) {
                                readArticles[itemId] = new Date().toISOString();
                                localStorage.setItem("read", JSON.stringify(readArticles));

                                // Mark the article as read in the articles array
                                articles[articleIndex].isRead = true;

                                // Get the parent container of the clicked skip button
                                const articleContainer = skipButton.closest(".article-container");

                                // Update the Open button behavior
                                updateOpenButton(articleContainer);

                                // Move the article container to the end of the list
                                moveCardToEnd(articleContainer);

                                // Update the unread count
                                updateItemCount();
                            }
                        });

                        const RemoveFeedButton = article.querySelector(".remove_feed");

                        RemoveFeedButton.addEventListener("click", function() {
                            if (feedUrl == "undefined" || typeof feedUrl == "undefined") {
                                // Can delete after Start of Dec 2024
                                alert("This card was saved with an old version of this site and we don't have the information needed to remove the feed. Use the My Feeds button at the top of the page.")
                            } else if (rssFeeds.includes(feedUrl)) {
                                let text = "Choose OK to remove: "+feedTitle+"\n\n"+feedUrl+"\n\nChoose Cancel to keep things as they are. Note: If you remove this feed, old posts will remain visable in your timeline, but we will not fetch new ones.";
                                if (confirm(text) == true) {
                                    //console.log(rssFeeds)
                                    //console.log("Removing",feedUrl)
                                    const feedIndex = rssFeeds.indexOf(feedUrl);
                                    rssFeeds.splice(feedIndex, 1);
                                    updateFeedList();
                                    //console.log(rssFeeds)
                                }
                            } else {
                                alert("It looks like this feed has already been removed. Remember, old posts from removed feeds remain visable in your timeline, but new ones are not fetched.")
                            }
                        });        
                        i+=1;
                    }                    
                });

                // After all articles are displayed, update their styles
                updateArticleStyles();

            }

            function StandardDeviation(arr) {
                // Creating the mean with Array.reduce
                let mean = arr.reduce((acc, curr) => {
                    return acc + curr
                }, 0) / arr.length;

                // Assigning (value - mean) ^ 2 to
                // every array item
                arr = arr.map((k) => {
                    return (k - mean) ** 2
                });

                // Calculating the sum of updated array
                let sum = arr.reduce((acc, curr) => acc + curr, 0);

                // Calculating the variance
                let variance = sum / arr.length

                // Returning the standard deviation
                return [mean, Math.sqrt(sum / arr.length)]
            }

            function cosinesim(A, B) {

                var dotproduct = 0;
                var mA = 0;
                var mB = 0;

                for(var i = 0; i < A.length; i++) {
                    dotproduct += A[i] * B[i];
                    mA += A[i] * A[i];
                    mB += B[i] * B[i];
                }


                mA = Math.sqrt(mA);
                mB = Math.sqrt(mB);


                var similarity = dotproduct / (mA * mB);

                if (isNaN(similarity)) {
                    similarity = 0
                }

                return similarity;
            }

            function getRating(inputString) {

                //console.log(inputString)

                tf = countWords(inputString)

                var array1 = [];
                var array2 = [];
                for (word in upTFIDF) {
                    if (dfreq["df_arr"][word]) {
                        idf = Math.log(1+dfreq["n_docs"]/dfreq["df_arr"][word]);
                        if (isNaN(idf)) {
                            idf = 1;
                        }
                        if (tf[word] && idf) {
                            //if (downTFIDF[word]*savednegativity<=tf[word]) {
                            //    array1.push((tf[word]-downTFIDF[word]*savednegativity)*idf)
                            //} else if (downTFIDF[word]*savednegativity>tf[word]) {
                            //    array1.push(0)
                            //} else {
                                array1.push((tf[word])*idf)
                            //}
                        } else {
                            array1.push(0)
                        }
                        array2.push(upTFIDF[word]*idf)
                    }
                }
                up_score = cosinesim(array1, array2);
                
                var array1 = [];
                var array2 = [];
                for (word in downTFIDF) {
                    if (dfreq["df_arr"][word]) {
                        idf = Math.log(1+dfreq["n_docs"]/dfreq["df_arr"][word]);
                        if (isNaN(idf)) {
                            idf = 1;
                        }
                        if (tf[word] && idf) {
                            //if (upTFIDF[word]*(2-savednegativity)<=tf[word]) {
                            //    array1.push((tf[word]-upTFIDF[word]*(2-savednegativity))*idf)
                            //} else if (upTFIDF[word]*(2-savednegativity)>tf[word]) {
                            //    array1.push(0)
                            //} else {
                                array1.push((tf[word])*idf)
                            //}
                        } else {
                            array1.push(0)
                        }
                        array2.push(downTFIDF[word]*idf)
                    }
                }
                down_score = cosinesim(array1, array2);
                
                score = up_score - down_score*savednegativity;
                //console.log(score)
                
                return score;
            }

            function get_words(inputString){
                const all_words = inputString.toLowerCase().match(/\b\w+\b/g);
                const words = []
                for (word in all_words){
                    if (!stopwords.includes(all_words[word])) {
                        words.push(all_words[word])
                    }
                }
                //console.log(words)
                return words
            }

            function countWords(inputString) {
                const words = get_words(inputString);

                if (!words) {
                    return {};
                }

                const wordCount = {};
                words.forEach(word => {
                    if (wordCount[word]) {
                        wordCount[word]++;
                    } else {
                        wordCount[word] = 1;
                    }
                });

                return wordCount;
            }

            function countWordsInArray(arrayOfStrings) {
                const wordCount = {};

                arrayOfStrings.forEach(inputString => {
                    const words = get_words(inputString);

                    if (words) {
                        const uniqueWords = new Set(words);

                        uniqueWords.forEach(word => {
                            if (wordCount[word]) {
                                wordCount[word]++;
                            } else {
                                wordCount[word] = 1;
                            }
                        });
                    }
                });

                return wordCount;
            }

            function extractText(articles) {
                const extractedTexts = [];

                articles.forEach(article => {
                    const { feedTitle, title, description } = article;
                    const extractedText = `${feedTitle.replace(/[^a-zA-Z]/g,"")}\n${title}\n${description}`;
                    extractedTexts.push(extractedText);
                });

                return extractedTexts;
            }

            function calculateDF(readArticleData) {
                const read_docs = extractText(readArticleData)
                const df = countWordsInArray(read_docs)
                return {"df_arr":df,"n_docs":read_docs.length}
            }

            function calculateTFIDF(votedArticles,df) {

                n_composite_docs = votedArticles.length;
                
                const documents = votedArticles.map(article => article.feedTitle.replace(/[^a-zA-Z]/g,"")+' '+article.title+' '+article.description);
                const doc = documents.join(' ').replace(/[^a-zA-Z]\d+[^a-zA-Z]/g,"");

                tf = countWords(doc)

                return tf;
            }

            function topWords(wordObj,exclude) {         

                //console.log(wordObj)
                
                for (word in wordObj){
                    //if (exclude[word]<=wordObj[word]) {
                    //    wordObj[word] = (wordObj[word]-exclude[word])/dfreq["df_arr"][word]
                    //} else if (exclude[word]>wordObj[word]) {
                    //    wordObj[word] = 0
                    //} else {
                        idf = Math.log(1+dfreq["n_docs"]/dfreq["df_arr"][word]);
                        if (isNaN(idf)) {
                            idf = 1;
                        }
                        wordObj[word] = wordObj[word]*idf;
                    //}
                }

                const pickHighest = (wordObj, num = 1) => {
                    const requiredObj = {};
                    if(num > Object.keys(wordObj).length){
                        return false;
                    };
                    Object.keys(wordObj).sort((a, b) => wordObj[b] - wordObj[a]).forEach((key, ind) =>
                    {
                        if(ind < num){
                            requiredObj[key] = wordObj[key];
                        }
                    });
                    return requiredObj;
                };

                n = 60;
                word_list = pickHighest(wordObj, n)
                if (Object.keys(word_list).length>0) {
                    i = 0
                    words = ""
                    for (word in word_list) {
                        if (i==0){
                            words += " "
                        } else if (i<(n-1)) {
                            words += ", "
                        } else {
                            words += ", &amp; "
                        }
                        words += word + " ("+Math.round(word_list[word])+")"
                        i+=1
                    }
                } else {
                    words = "<i>not enough data</i>"
                }

                return words+". "
            }
                    
            function displayErrorPopup(feedTitle, feedUrl, errorMessage) {
                const errorModal = `
                    <div class="modal fade" id="errorModal" tabindex="-1" aria-labelledby="errorModalLabel" aria-hidden="true">
                        <div class="modal-dialog">
                            <div class="modal-content">
                                <div class="modal-header">
                                    <h5 class="modal-title" id="errorModalLabel">Error Fetching Feed</h5>
                                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                                </div>
                                <div class="modal-body">
                                    <p><strong>Feed:</strong> ${feedTitle}</p>
                                    <p><strong>Feed URL:</strong> ${feedUrl}</p>
                                    <p><strong>Error Message:</strong> ${errorMessage}</p>
                                    <p>Sometimes there are issues reaching a feed. If this error persists, you can remove this feed using the "My Feeds" button.</p>
                                </div>
                                <div class="modal-footer">
                                    <button id="manage-feeds" class="btn btn-primary" style="width:100%" onClick="window.open('https://github.com/colarusso/rss_algo/tree/main#troubleshooting');">Troubleshoot this error</button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;

                document.body.insertAdjacentHTML("beforeend", errorModal);

                const errorModalElement = document.getElementById("errorModal");
                errorModalElement.addEventListener("hidden.bs.modal", function() {
                    errorModalElement.remove();
                });

                new bootstrap.Modal(errorModalElement).show();
            }

            function filterOldEntries(entries) {

                //console.log(entries)
                
                const currentDate = new Date();
                const twoWeeksAgo = new Date();
                twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 90);

                const filteredEntries = {};

                for (const link in entries) {
                    const entryDate = new Date(entries[link]);
                    if (entryDate >= twoWeeksAgo) {
                        filteredEntries[link] = entries[link];
                    }
                }

                // Convert the object into an array of key-value pairs
                const dataArray = Object.entries(filteredEntries);
                if (dataArray.length>=max_arts*1.7) {
                    // Sort the array based on the date values
                    dataArray.sort((a, b) => new Date(a[1]) - new Date(b[1]));
                    // Convert the sorted array back into an object
                    //console.log("To free up space, we're forgetting about some of your older articles. If they're still in the live RSS feed, you may see them again.")
                    //console.log(dataArray)
                    keep_last = Math.floor(max_arts*1.7);
                    lastn_filteredEntries = Object.fromEntries(dataArray.slice(-keep_last));
                    //console.log(dataArray)
                    lastn_filteredEntries = filteredEntries
                } else {
                    lastn_filteredEntries = filteredEntries
                }

                localStorage.setItem("read", JSON.stringify(lastn_filteredEntries));
                return lastn_filteredEntries;
            }

            function countUnreadArticles() {
                const cardElements = document.querySelectorAll(".article-container");
                let unreadCount = 0;
                cardElements.forEach(card => {
                    if (!card.classList.contains("read-article")) {
                        unreadCount++;
                    }
                });
                return unreadCount;
            }

            function updateItemCount() {
                //lazyload();

                const readCount = Object.keys(readArticles).length.toLocaleString("en-US");;
                const unreadCount = countUnreadArticles().toLocaleString("en-US");; 
                const readCountElement = document.getElementById("read-count");
                const unreadCountElement = document.getElementById("unread-count");
                if (readCount<=1000) {
                    readCountElement.textContent = `Seen: ${readCount}`;
                } else {
                    readCountElement.textContent = `Seen: 1,000+`;
                }
                unreadCountElement.textContent = `New: ${unreadCount}`;

                var readArticleData = articles.filter(article => readArticles[article.itemId]);
                var upvotedArticleData = articles.filter(article => upvotes[article.itemId]);
                var downvotedArticleData = articles.filter(article => downvotes[article.itemId]);
                dfreq = calculateDF(readArticleData)
                let upTFIDF = calculateTFIDF(upvotedArticleData,dfreq);
                let downTFIDF = calculateTFIDF(downvotedArticleData,dfreq);

                localStorage.setItem("upTFIDF", JSON.stringify(upTFIDF));
                localStorage.setItem("downTFIDF", JSON.stringify(downTFIDF));

                document.getElementById('upwords').innerHTML = topWords(upTFIDF,downTFIDF);
                document.getElementById('downwords').innerHTML = topWords(downTFIDF,upTFIDF);

                //console.log("TF-IDF: "+readArticleData.length+" 'read' documents","\nUp: "+upvotedArticleData.length+" documents, "+Object.keys(upTFIDF).length+" words","\nDown: "+downvotedArticleData.length+" documents, "+Object.keys(downTFIDF).length+" words\n");

                var order_arr = []
                //console.log("Updating Order")
                for (article in articles){
                    order_arr.push([articles[article].isRead,articles[article].priorityRating,new Date(articles[article].pubDate).toLocaleString(),articles[article].title,articles[article].itemId])
                }
                
                localStorage.setItem("articles", JSON.stringify(articles));                

            }

            const clearUpvotesButton = document.getElementById("clear-upvotes");
            clearUpvotesButton.addEventListener("click", function() {
                // Clear the "read" key from localStorage
                localStorage.removeItem("upvotes");

                // Clear the read status of all articles in the upvotes object
                for (var member in upvotes) delete upvotes[member];

                // Update article styles and the feed list
                updateFeedList();            
            });

            const clearDownvotesButton = document.getElementById("clear-downvotes");
            clearDownvotesButton.addEventListener("click", function() {
                // Clear the "read" key from localStorage
                localStorage.removeItem("downvotes");

                // Clear the read status of all articles in the downvotes object
                for (var member in downvotes) delete downvotes[member];

                // Update article styles and the feed list
                updateFeedList();
            });

            const clearReadHistoryButton = document.getElementById("clear-read-history");
            clearReadHistoryButton.addEventListener("click", function() {
                // Clear the "read" key from localStorage
                localStorage.removeItem("read");

                // Clear the read status of all articles in the readArticles object
                for (var member in readArticles) delete readArticles[member];

                articles = [];
                localStorage.setItem("articles", JSON.stringify(articles));
                let lastLoad = 0;
                localStorage.setItem("lastLoad", 0);

                //resetReadStatus();

                // Reorder the articles to reflect the changes
                //reorderArticles();

                // Update article styles and the feed list
                updateFeedList(true);
            });            
            
            loadNews(true);

            const addFeedButton = document.getElementById("add-feed");
            const manageFeedsButton = document.getElementById("manage-feeds");

            addFeedButton.addEventListener("click", function() {
                if (rssFeeds.length>=40) {
                    alert("Generally speaking, the more feeds you follow the more posts in your timeline and the slower the site will preform. You can shrink the size of your timeline but setting a shorter History window. Also, to accommodate large feed follows, we truncate feeds to avoid overloading your browser's storage. How much we have to cut is proportional to how many feeds you follow. So following a lot of feeds may cause you to miss posts if they are too far down the feed. If this issue comes up, consider following fewer feeds or checking in more often.")
                }

                const newFeedUrl = prompt("Enter the URL for a new RSS feed:");
                if (newFeedUrl) {
                    let lastLoad = 0;
                    localStorage.setItem("lastLoad", 0);
                    rssFeeds.push(newFeedUrl);
                    updateFeedList(true,newFeedUrl);
                }
                
            });

            manageFeedsButton.addEventListener("click", function() {
                const feedList = rssFeeds.map((feed, index) => `
                        <tr><td width="1%">
                        <button class="btn btn-danger remove-feed" data-feed-index="${index}">Remove</button>
                        </td><td width="100%"><textarea style="width:100%;word-wrap:break-word;resize: none;" readonly>${feed}</textarea></td></tr>
                `).join("");

                const feedListModal = `
                    <div class="modal fade" id="feedListModal" tabindex="-1" aria-labelledby="feedListModalLabel" aria-hidden="true">
                        <div class="modal-dialog">
                            <div class="modal-content">
                                <div class="modal-header">
                                    <h5 class="modal-title" id="feedListModalLabel">My Feeds</h5>
                                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                                </div>
                                <div class="modal-body">
                                    <p>Note: If you remove a feed, old articles will remain on your timeline and in your history by default. Also, if you need help finding feeds, check out our <a href="https://github.com/SuffolkLITLab/rss_algo/tree/main#notes-on-rss-feeds" target="_blank">notes on RSS feeds</a>.</p>
                                    <p>
                                        <button type="button" id="remove_all_add_defaults" class="btn btn-danger remove_all">Remove All &amp; Load Defaults</button>
                                        <button type="button" id="remove_all_feeds" class="btn btn-danger remove_all">Remove All</button>
                                    <p>
                                    <table cellpadding="10px" width="100%">${feedList}</table>
                                </div>
                            </div>
                        </div>
                    </div>
                `;

                document.body.insertAdjacentHTML("beforeend", feedListModal);


                const feedListModalElement = document.getElementById("feedListModal");
                feedListModalElement.addEventListener("hidden.bs.modal", function() {
                    feedListModalElement.remove();
                });

                const removeALLaddDefaults = document.getElementById("remove_all_add_defaults");
                const removeALLfeeds = document.getElementById("remove_all_feeds");
                
                removeALLaddDefaults.addEventListener("click", function() {
                    rssFeeds = default_feeds
                    feedListModalElement.querySelector("table").innerHTML = rssFeeds.map((feed, index) => `
                        <tr><td width="1%">
                        <button class="btn btn-danger remove-feed" data-feed-index="${index}">Remove</button>
                        </td><td width="100%"><textarea style="width:100%;word-wrap:break-word;resize: none;" readonly>${feed}</textarea></td></tr>
                    `).join("");
                    let lastLoad = 0;
                    localStorage.setItem("lastLoad", 0);    
                    updateFeedList(true);
                });

                removeALLfeeds.addEventListener("click", function() {
                    rssFeeds = []
                    feedListModalElement.querySelector("table").innerHTML = rssFeeds.map((feed, index) => `
                        <tr><td width="1%">
                        <button class="btn btn-danger remove-feed" data-feed-index="${index}">Remove</button>
                        </td><td width="100%"><textarea style="width:100%;word-wrap:break-word;resize: none;" readonly>${feed}</textarea></td></tr>
                    `).join("");
                    updateFeedList();
                });

                feedListModalElement.querySelector(".modal-body").addEventListener("click", function(event) {
                    if (event.target.classList.contains("remove-feed")) {
                        const feedIndex = event.target.getAttribute("data-feed-index");
                        rssFeeds.splice(feedIndex, 1);
                        updateFeedList();
                        feedListModalElement.querySelector("table").innerHTML = rssFeeds.map((feed, index) => `
                            <tr><td width="1%">
                            <button class="btn btn-danger remove-feed" data-feed-index="${index}">Remove</button>
                            </td><td width="100%"><textarea style="width:100%;word-wrap:break-word;resize: none;" readonly>${feed}</textarea></td></tr>
                        `).join("");
                    }
                });

                new bootstrap.Modal(feedListModalElement).show();
            });

            

        });

    </script>
    
</body>
</html>
